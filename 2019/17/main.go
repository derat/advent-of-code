package main

import (
	"fmt"
	"time"

	"github.com/derat/advent-of-code/lib"
)

const animate = false

func main() {
	input := lib.InputInt64s("2019/17")

	// Part 1: Print sum of r*c of intersections.
	vm := lib.NewIntcode(input)

	var inRow bool
	var grid [][]byte
	vm.OutFunc = func(v int64) {
		switch v {
		case 10: // newline
			inRow = false
		default:
			if !inRow {
				grid = append(grid, []byte{})
				inRow = true
			}
			r := len(grid) - 1
			grid[r] = append(grid[r], byte(v))
		}
	}
	lib.Assert(vm.Run())

	nrows := len(grid)
	ncols := len(grid[0])
	for _, r := range grid {
		lib.AssertEq(len(r), ncols)
	}

	var sum int
	for r := 1; r < nrows-1; r++ {
		for c := 1; c < ncols-1; c++ {
			if grid[r][c] == '#' && grid[r-1][c] == '#' && grid[r+1][c] == '#' &&
				grid[r][c-1] == '#' && grid[r][c+1] == '#' {
				sum += r * c
			}
		}
	}
	fmt.Println(sum)

	// Part 2: Visit every part of the path at least once and print the resulting value.
	vm = lib.NewIntcode(input)
	vm.Mem[0] = 2

	var drawn bool
	var lastOut int64
	inRow = false
	grid = nil
	vm.OutFunc = func(v int64) {
		if animate {
			switch v {
			case 10: // newline
				inRow = false
				if len(grid) == nrows {
					if drawn {
						fmt.Printf("\033[%dA", nrows)
					}
					fmt.Println(lib.DumpBytes(grid))
					time.Sleep(50 * time.Millisecond)
					drawn = true // clear next time
					grid = nil   // reset for next frame
				}
			default:
				if !inRow {
					grid = append(grid, make([]byte, 0, ncols))
					inRow = true
				}
				r := len(grid) - 1
				grid[r] = append(grid[r], byte(v))
			}
		}
		lastOut = v
	}

	cmd := "A,C,C,B,A,C,B,A,C,B\n" + // main program
		"L,6,R,12,L,4,L,6\n" + // A
		"L,6,L,10,L,10,R,6\n" + // B
		"R,6,L,6,R,12\n" // C
	if animate {
		cmd += "y\n" // continuous video
	} else {
		cmd += "n\n"
	}

	var nin int
	vm.InFunc = func() int64 {
		ch := int64(cmd[nin])
		nin++

		// The program prints an annoying prompt after the first frame, and
		// before prompting for input:
		//
		//	Main:
		//	Function A:
		//	Function B:
		//	Function C:
		//	Continuous video feed?
		//
		// It messes up the animation, so clear it.
		if nin == len(cmd) {
			grid = nil
			inRow = false
		}

		return ch
	}

	lib.Assert(vm.Run())
	fmt.Println(lastOut)

	// Here's what the grid generated by my input looks like:
	//
	//	#######..................................
	//	#.....#..................................
	//	#.....#..................................
	//	#.....#..................................
	//	#.....#..................................
	//	#.....#..................................
	//	#.....#.......................#####......
	//	#.....#.......................#...#......
	//	#.....#.......................#...#......
	//	#.....#.......................#...#......
	//	###########.................###########..
	//	......#...#.................#.#...#...#..
	//	......#######...........#######...#...#..
	//	..........#.#...........#...#.....#...#..
	//	..........#.#...........#...#.....#...#..
	//	..........#.#...........#...#.....#...#..
	//	..........#######.......#.#############..
	//	............#...#.......#.#.#.....#......
	//	............#############.#.#.....######^
	//	................#.........#.#............
	//	................#.....#######............
	//	................#.....#...#..............
	//	................#...#######..............
	//	................#...#.#..................
	//	................#...#.#..................
	//	................#...#.#..................
	//	..........#############..................
	//	..........#.....#...#....................
	//	..........#.....#####....................
	//	..........#..............................
	//	..........#######........................
	//	................#........................
	//	................#.#......................
	//	................#.#......................
	//	................#.#......................
	//	................#.#......................
	//	................#######..................
	//	..................#...#..................
	//	..................###########............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#.....#............
	//	......................#######............
	//
	// This path goes through the whole thing:
	//
	//	L,6,R,12,L,4,L,6,R,6,L,6,R,12,R,6,L,6,R,12,L,6,L,10,
	//	L,10,R,6,L,6,R,12,L,4,L,6,R,6,L,6,R,12,L,6,L,10,L,10,
	//	R,6,L,6,R,12,L,4,L,6,R,6,L,6,R,12,L,6,L,10,L,10,R,6
	//
	// After a lot of fiddling around, I manually compressed it to the following:
	//
	//	   A,C,C,B,A,C,B,A,C,B
	//	A: L,6,R,12,L,4,L,6
	//	B: L,6,L,10,L,10,R,6
	//	C: R,6,L,6,R,12
}
